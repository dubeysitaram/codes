<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# Mastering the `const` Keyword in C++

A concise guide that gathers the most common interview gotchas, best practices, and code patterns around C++’s `const`.

## 📌 Why `const` Matters

- **Expresses intent** – signals variables or functions that must **not modify** data.
- **Enables compiler checks** – catches accidental writes at compile-time.
- **Improves API design** – lets callers know what they can (and can’t) do.
- **Optimizes code** – gives the compiler freedom to place data in read-only memory and perform additional optimizations.


## ⚡️ Quick Cheat Sheet

| Syntax | Meaning | What is immutable? |
| :-- | :-- | :-- |
| `const int x` | constant object | value |
| `int * const p` | constant pointer | address stored in `p` |
| `const int * p`<br>`int const * p` | pointer to constant data | data pointed to |
| `const int * const p` | constant pointer to constant data | address **and** data |
| `void foo() const` | constant member function | the *object’s* state |

## 🔥 Tricky Interview Questions \& Answers

### 1. Can a `const` member function modify data?

**No.** Unless the data member is declared `mutable`.

```cpp
class A {
    int  x = 5;
    void show() const {
        // x = 10;   // ❌ compile-time error
    }
};
```


### 2. Why add `const` after a member-function signature?

Marks the function as *read-only*; it can be invoked on `const` objects and is forbidden to mutate non-`mutable` data.

### 3. Pointer vs. pointee immutability

```cpp
const int*  p;  // value unchangeable
int* const  p;  // address unchangeable
const int* const p; // both fixed
```

Rule of thumb: read **right-to-left**; the word nearest `const` is what stays constant.

### 4. Can you overload on `const`?

Yes. Constant and non-constant versions are distinct.

```cpp
struct Test {
    void print()       { std::cout << "non-const\n"; }
    void print() const { std::cout << "const\n";    }
};
```


### 5. Returning a `const` value – useful?

Only when returning a **reference or pointer** to forbid the caller from mutating the referred object.

```cpp
const int& get() {
    static int x = 42;
    return x;       // caller cannot modify
}
```


### 6. Mutating data inside a `const` function

Allowed **only** for members marked `mutable`.

```cpp
class Logger {
    mutable std::size_t calls = 0;
    void log() const { ++calls; }   // legal
};
```


### 7. Can a constructor be `const`?

No. Constructors **must** alter the object’s state during initialization.

### 8. Pass-by-value vs. `const &`

- Prefer **`const Type&`** for large objects (e.g., `std::string`, complex structs) to avoid copies.
- For small, trivially copyable types (ints, pointers) pass by value.


### 9. `const` on a by-value parameter

```cpp
void func(const int x);  // ‘const’ is useless – caller’s copy unaffected
```


### 10. What happens if you modify a `const` object?

The compiler blocks any data mutation or call to a non-`const` member function.

## 💡 Best Practices

- Mark functions `const` **by default**; remove `const` only when mutation is required.
- Prefer `const` for **temporary variables** inside long functions to document invariants.
- Combine `const` with **smart pointers** (`std::unique_ptr<const T>`, `std::shared_ptr<const T>`) to enforce read-only semantics across owners.
- Use `constexpr` instead of `const` for compile-time constants when possible.


## 🚧 Common Pitfalls

- Forgetting `const` on the *function* makes the method unusable on `const` objects.
- Placing `const` in the wrong position on pointers changes what is protected.
- Declaring a *value* parameter `const` adds no protection for the caller.
- Writing `const` data without `mutable` inside a supposedly read-only member function triggers hard-to-debug errors.


## 🧩 All-in-One Example

```cpp
#include <iostream>
class Demo {
    int        a = 5;          // ordinary data
    mutable int b = 10;        // can change even in const function
public:
    void change() const {
        // a = 20;             // ❌ illegal
        b = 20;                // ✅ allowed
    }

    int get() const { return a; }      // const overload
    void get()       { std::cout << "non-const\n"; } // non-const overload
};

int main() {
    const Demo d;
    d.get();    // calls const version
    d.change(); // mutates only b
}
```


## 📚 Further Reading

- *Effective C++* – Scott Meyers, Items 3 \& 21
- *C++ Core Guidelines* – sections on const-correctness
- cppreference.com – detailed reference for `const`, `constexpr`, `mutable`

Happy coding — and may your `const` always be correct!
